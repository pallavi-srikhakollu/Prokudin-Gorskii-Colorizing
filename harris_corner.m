%Refered from https://github.com/gokhanozbulak/Harris-Detector/blob/master/src/harris.mclc;Threshold = 50000;GorskiiImage=(imread('image6.jpg'));[ height ,width]=size(GorskiiImage);height= floor(height/3);B=GorskiiImage(1:height,:);G=GorskiiImage( height + 1:2*height,:);R =GorskiiImage( 2*height+1:3*height,:);disp("Images read")sigma = 1;[gx, gy] = meshgrid(-3:3, -3:3);Guassian_Kernel = exp(-(gx .^ 2 + gy .^ 2) / (2 * sigma ^ 2));Guassian_x = gx .* exp(-(gx .^ 2 + gy .^ 2) / (2 * sigma ^ 2));Guassian_y = gy .* exp(-(gx .^ 2 + gy .^ 2) / (2 * sigma ^ 2));disp("Guassian calculated")% 1) Compute x and y derivatives of imageIxB = conv2(Guassian_x, B);IyB = conv2(Guassian_y, B);IxG = conv2(Guassian_x, G);IyG = conv2(Guassian_y, G);IxR = conv2(Guassian_x, R);IyR = conv2(Guassian_y, R);%{% 2) Compute products of derivatives at every pixeldisp("Pixel for each valu")Ix2B = IxB .^ 2;Iy2B = IyB .^ 2;IxyB = IxB .* IyB;Ix2G = IxG .^ 2;Iy2G = IyG .^ 2;IxyG = IxG .* IyG;Ix2R = IxR .^ 2;Iy2R = IyR .^ 2;IxyR = IxR .* IyR;rows = size(B, 1);cols = size(B, 2);% 3)Compute the sums of the products of derivatives at each pixelSx2G = conv2(Guassian_x, Ix2G);Sy2G = conv2(Guassian_x, Iy2G);SxyG = conv2(Guassian_Kernel, IxyG);disp("Sum of products")Sx2B = conv2(Guassian_x, Ix2B);Sy2B = conv2(Guassian_x, Iy2B);SxyB = conv2(Guassian_Kernel, IxyB);Sx2R = conv2(Guassian_x, Ix2R);Sy2R = conv2(Guassian_x, Iy2R);SxyR = conv2(Guassian_Kernel, IxyR);disp("intialising images for features")imR = zeros(rows, cols);imG = zeros(rows, cols);imB = zeros(rows, cols);FeaturesR = zeros(2000,0); for x= 1:rows-5        for y=1:cols-5          % 4) Define at each pixel(x, y) the matrix H           HG = [Sx2G(x, y) SxyG(x, y); SxyG(x, y) Sy2G(x, y)];           HB = [Sx2B(x, y) SxyB(x, y); SxyB(x, y) Sy2B(x, y)];           HR = [Sx2R(x, y) SxyR(x, y); SxyR(x, y) Sy2R(x, y)];                     % 5) Compute the response of the detector at each pixel          RR = det(HR) - k * (trace(HR) ^ 2);          RB = det(HB) - k * (trace(HB) ^ 2);          RG = det(HG) - k * (trace(HG) ^ 2);                   % 6) Threshold on value of R          if (RR > Threshold)            imR(x, y) = RR;             end                      if (RB > Threshold)            imB(x, y) = RB;             end                      if (RG > Threshold)            imG(x, y) = RG;             end      
     endfor        endfordisp("Output done")% 7) Compute nonmax suppressionoutputR = imR > imdilate(imR, [1 1 1; 1 0 1; 1 1 1]);outputG = imG > imdilate(imG, [1 1 1; 1 0 1; 1 1 1]);outputB = imB > imdilate(imB, [1 1 1; 1 0 1; 1 1 1]);disp("Working on show")figure, imshow(B);figure, imshow(outputR);figure, imshow(outputG);figure, imshow(outputB); #featureG = outputG(outputG~=0)%}%{msize = numel(featureG);randB = randperm(msize,1);v = B(randB);[r,c] = ind2sub(size(B),randB);disp(r)disp(c) %}%{while ( outputB(idxB(1:x))~= 0)  idxB = randperm(msize);  r, c = ind2sub(rows, cols, idxB(:));  endwhilewhile ( outputB(idxR(1:x))~= 0)  idxR = randperm(msize);  [r1, c1] = ind2sub([rows, cols], idxR(:));endwhileoffsetx  = (r[0,0]-r1[0,0]) offsety = (c-c1)sumr = sum(sum((idxB-idxR).^2))%}%for pixel = 1:outputG(outputG~=0) %  disp(pixel)%endfor