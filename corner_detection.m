%Refered from https://github.com/gokhanozbulak/Harris-Detector/blob/master/src/harris.mclc;function corner_detect = corner_detect ()Threshold = 50000;k = 0.04;GorskiiImage=(imread('image6.jpg'));[ height ,width]=size(GorskiiImage);height= floor(height/3);B=GorskiiImage(1:height,:);G=GorskiiImage( height + 1:2*height,:);R =GorskiiImage( 2*height+1:3*height,:);disp("Images read")sigma = 1;[gx, gy] = meshgrid(-3:3, -3:3);Guassian_Kernel = exp(-(gx .^ 2 + gy .^ 2) / (2 * sigma ^ 2));Guassian_x = gx .* exp(-(gx .^ 2 + gy .^ 2) / (2 * sigma ^ 2));Guassian_y = gy .* exp(-(gx .^ 2 + gy .^ 2) / (2 * sigma ^ 2));disp("Guassian calculated")%convoling with gussian filterIxB = conv2(Guassian_x, B);IyB = conv2(Guassian_y, B);IxG = conv2(Guassian_x, G);IyG = conv2(Guassian_y, G);IxR = conv2(Guassian_x, R);IyR = conv2(Guassian_y, R);%pixel derivativesdisp("Pixel for each valu")Ix2B = IxB .^ 2;Iy2B = IyB .^ 2;IxyB = IxB .* IyB;Ix2G = IxG .^ 2;Iy2G = IyG .^ 2;IxyG = IxG .* IyG;Ix2R = IxR .^ 2;Iy2R = IyR .^ 2;IxyR = IxR .* IyR;rows = size(B, 1);cols = size(B, 2);%sum of productsSx2G = conv2(Guassian_x, Ix2G);Sy2G = conv2(Guassian_x, Iy2G);SxyG = conv2(Guassian_Kernel, IxyG);disp("Sum of products")Sx2B = conv2(Guassian_x, Ix2B);Sy2B = conv2(Guassian_x, Iy2B);SxyB = conv2(Guassian_Kernel, IxyB);Sx2R = conv2(Guassian_x, Ix2R);Sy2R = conv2(Guassian_x, Iy2R);SxyR = conv2(Guassian_Kernel, IxyR);disp("intialising images for features")imR = zeros(rows, cols);imG = zeros(rows, cols);imB = zeros(rows, cols);for x= 1:rows-5        for y=1:cols-5          % We Define at each pixel(x, y) the matrix H           HG = [Sx2G(x, y) SxyG(x, y); SxyG(x, y) Sy2G(x, y)];           HB = [Sx2B(x, y) SxyB(x, y); SxyB(x, y) Sy2B(x, y)];           HR = [Sx2R(x, y) SxyR(x, y); SxyR(x, y) Sy2R(x, y)];                     RR = det(HR) - k * (trace(HR) ^ 2);          RB = det(HB) - k * (trace(HB) ^ 2);          RG = det(HG) - k * (trace(HG) ^ 2);                   % Threshold on value of R          if (RR > Threshold)            imR(x, y) = RR;             end                      if (RB > Threshold)            imB(x, y) = RB;             end                      if (RG > Threshold)            imG(x, y) = RG;             end           endfor        endfor %  Computing  nonmax suppressionoutputR = imR > imdilate(imR, [1 1 1; 1 0 1; 1 1 1]);outputG = imG > imdilate(imG, [1 1 1; 1 0 1; 1 1 1]);outputB = imB > imdilate(imB, [1 1 1; 1 0 1; 1 1 1]);figureimshow(B);%uiwait(msgbox('Locate the point'));hold on % Prevent image from being blown away.[x,y] = find(outputB == 1);plot(y,x, 'r+', 'Markersize', 5);%imshow(B);imwrite(B,"imageMarker.png");%Picking out a random point from features of Bmsize = numel(outputB);idxB = randperm(msize,1);vb = outputB(idxB);while(vb~=0)    idxB = randperm(msize,1);     vb = outputB(idxB)     [rb,cb] = ind2sub(size(outputB),idxB);endwhile[rb,cb] = ind2sub(size(outputB),idxB);disp(rb)%Picking out a random point from features of Gmsizeg = numel(outputG);idxG = randperm(msizeg,1);vg = outputB(idxG);[rg,cg] = ind2sub(size(outputG),idxG);disp(rb)%Checking if the output value is zero pixelwhile(vg~=0)    idxG = randperm(msize,1);     vg = outputG(idxG);     [rg,cg] = ind2sub(size(outputG),idxG);endwhile     shiftx = rb-rg;shifty = cb-cg;ssd_g = 1000000000;threshold = 40;inliners = 0;point = zeros(200,2);t = 0for index = 1:1:200  [r,c] = ind2sub(size(outputB),index);  v = outputB(index);   if (v~=0)    t = t+1;     point(t,:)= [r c]  endifendforend                  